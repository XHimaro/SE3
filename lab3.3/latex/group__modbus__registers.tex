\hypertarget{group__modbus__registers}{}\doxysection{Modbus Registers}
\label{group__modbus__registers}\index{Modbus Registers@{Modbus Registers}}
\doxysubsection*{Функции}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__modbus_ga9e7fce8c431cb0e521c67f7f36dd823d}{e\+MBError\+Code}} \mbox{\hyperlink{group__modbus__registers_ga7816677520b1eb2ebecf15060a41bc81}{e\+MBReg\+Input\+CB}} (UCHAR $\ast$puc\+Reg\+Buffer, USHORT us\+Address, USHORT us\+NRegs)
\begin{DoxyCompactList}\small\item\em Callback function used if the value of a {\itshape Input Register} is required by the protocol stack. The starting register address is given by {\ttfamily us\+Address} and the last register is given by {\ttfamily us\+Address + us\+NRegs -\/ 1}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__modbus_ga9e7fce8c431cb0e521c67f7f36dd823d}{e\+MBError\+Code}} \mbox{\hyperlink{group__modbus__registers_ga10d37e1d80224bf3b1eeb9e246d7582e}{e\+MBReg\+Holding\+CB}} (UCHAR $\ast$puc\+Reg\+Buffer, USHORT us\+Address, USHORT us\+NRegs, \mbox{\hyperlink{group__modbus_gaf1398cbbeb317b1dbd0276b275f5b0f8}{e\+MBRegister\+Mode}} e\+Mode)
\begin{DoxyCompactList}\small\item\em Callback function used if a {\itshape Holding Register} value is read or written by the protocol stack. The starting register address is given by {\ttfamily us\+Address} and the last register is given by {\ttfamily us\+Address + us\+NRegs -\/ 1}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__modbus_ga9e7fce8c431cb0e521c67f7f36dd823d}{e\+MBError\+Code}} \mbox{\hyperlink{group__modbus__registers_ga88d9b719291515c60eee1bf9ffa1dd02}{e\+MBReg\+Coils\+CB}} (UCHAR $\ast$puc\+Reg\+Buffer, USHORT us\+Address, USHORT us\+NCoils, \mbox{\hyperlink{group__modbus_gaf1398cbbeb317b1dbd0276b275f5b0f8}{e\+MBRegister\+Mode}} e\+Mode)
\begin{DoxyCompactList}\small\item\em Callback function used if a {\itshape Coil Register} value is read or written by the protocol stack. If you are going to use this function you might use the functions \mbox{\hyperlink{group__modbus__utils_gaffd1defb8bceb85f1b65d64fa1c895e1}{x\+MBUtil\+Set\+Bits(  )}} and \mbox{\hyperlink{group__modbus__utils_ga94b3b43e1d2353e621748c79e2fb4dd5}{x\+MBUtil\+Get\+Bits(  )}} for working with bitfields. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__modbus_ga9e7fce8c431cb0e521c67f7f36dd823d}{e\+MBError\+Code}} \mbox{\hyperlink{group__modbus__registers_ga38101f5da54af137e210a3b8b9fa3887}{e\+MBReg\+Discrete\+CB}} (UCHAR $\ast$puc\+Reg\+Buffer, USHORT us\+Address, USHORT us\+NDiscrete)
\begin{DoxyCompactList}\small\item\em Callback function used if a {\itshape Input Discrete Register} value is read by the protocol stack. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Подробное описание}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{mb_8h}{mb.h}}"{}} }

\end{DoxyCode}
 The protocol stack does not internally allocate any memory for the registers. This makes the protocol stack very small and also usable on low end targets. In addition the values don\textquotesingle{}t have to be in the memory and could for example be stored in a flash.~\newline
 Whenever the protocol stack requires a value it calls one of the callback function with the register address and the number of registers to read as an argument. The application should then read the actual register values (for example the ADC voltage) and should store the result in the supplied buffer.~\newline
 If the protocol stack wants to update a register value because a write register function was received a buffer with the new register values is passed to the callback function. The function should then use these values to update the application register values. 

\doxysubsection{Функции}
\mbox{\Hypertarget{group__modbus__registers_ga88d9b719291515c60eee1bf9ffa1dd02}\label{group__modbus__registers_ga88d9b719291515c60eee1bf9ffa1dd02}} 
\index{Modbus Registers@{Modbus Registers}!eMBRegCoilsCB@{eMBRegCoilsCB}}
\index{eMBRegCoilsCB@{eMBRegCoilsCB}!Modbus Registers@{Modbus Registers}}
\doxysubsubsection{\texorpdfstring{eMBRegCoilsCB()}{eMBRegCoilsCB()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__modbus_ga9e7fce8c431cb0e521c67f7f36dd823d}{e\+MBError\+Code}} e\+MBReg\+Coils\+CB (\begin{DoxyParamCaption}\item[{UCHAR $\ast$}]{puc\+Reg\+Buffer,  }\item[{USHORT}]{us\+Address,  }\item[{USHORT}]{us\+NCoils,  }\item[{\mbox{\hyperlink{group__modbus_gaf1398cbbeb317b1dbd0276b275f5b0f8}{e\+MBRegister\+Mode}}}]{e\+Mode }\end{DoxyParamCaption})}



Callback function used if a {\itshape Coil Register} value is read or written by the protocol stack. If you are going to use this function you might use the functions \mbox{\hyperlink{group__modbus__utils_gaffd1defb8bceb85f1b65d64fa1c895e1}{x\+MBUtil\+Set\+Bits(  )}} and \mbox{\hyperlink{group__modbus__utils_ga94b3b43e1d2353e621748c79e2fb4dd5}{x\+MBUtil\+Get\+Bits(  )}} for working with bitfields. 


\begin{DoxyParams}{Аргументы}
{\em puc\+Reg\+Buffer} & The bits are packed in bytes where the first coil starting at address {\ttfamily us\+Address} is stored in the LSB of the first byte in the buffer {\ttfamily puc\+Reg\+Buffer}. If the buffer should be written by the callback function unused coil values (I.\+e. if not a multiple of eight coils is used) should be set to zero. \\
\hline
{\em us\+Address} & The first coil number. \\
\hline
{\em us\+NCoils} & Number of coil values requested. \\
\hline
{\em e\+Mode} & If e\+MBRegister\+Mode\+::\+MB\+\_\+\+REG\+\_\+\+WRITE the application values should be updated from the values supplied in the buffer {\ttfamily puc\+Reg\+Buffer}. If e\+MBRegister\+Mode\+::\+MB\+\_\+\+REG\+\_\+\+READ the application should store the current values in the buffer {\ttfamily puc\+Reg\+Buffer}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Возвращает}
The function must return one of the following error codes\+:
\begin{DoxyItemize}
\item e\+MBError\+Code\+::\+MB\+\_\+\+ENOERR If no error occurred. In this case a normal Modbus response is sent.
\item e\+MBError\+Code\+::\+MB\+\_\+\+ENOREG If the application does not map an coils within the requested address range. In this case a {\bfseries{ILLEGAL DATA ADDRESS}} is sent as a response.
\item e\+MBError\+Code\+::\+MB\+\_\+\+ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a {\bfseries{SLAVE DEVICE BUSY}} exception is sent as a response.
\item e\+MBError\+Code\+::\+MB\+\_\+\+EIO If an unrecoverable error occurred. In this case a {\bfseries{SLAVE DEVICE FAILURE}} exception is sent as a response. 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{group__modbus__registers_ga38101f5da54af137e210a3b8b9fa3887}\label{group__modbus__registers_ga38101f5da54af137e210a3b8b9fa3887}} 
\index{Modbus Registers@{Modbus Registers}!eMBRegDiscreteCB@{eMBRegDiscreteCB}}
\index{eMBRegDiscreteCB@{eMBRegDiscreteCB}!Modbus Registers@{Modbus Registers}}
\doxysubsubsection{\texorpdfstring{eMBRegDiscreteCB()}{eMBRegDiscreteCB()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__modbus_ga9e7fce8c431cb0e521c67f7f36dd823d}{e\+MBError\+Code}} e\+MBReg\+Discrete\+CB (\begin{DoxyParamCaption}\item[{UCHAR $\ast$}]{puc\+Reg\+Buffer,  }\item[{USHORT}]{us\+Address,  }\item[{USHORT}]{us\+NDiscrete }\end{DoxyParamCaption})}



Callback function used if a {\itshape Input Discrete Register} value is read by the protocol stack. 

If you are going to use his function you might use the functions \mbox{\hyperlink{group__modbus__utils_gaffd1defb8bceb85f1b65d64fa1c895e1}{x\+MBUtil\+Set\+Bits(  )}} and \mbox{\hyperlink{group__modbus__utils_ga94b3b43e1d2353e621748c79e2fb4dd5}{x\+MBUtil\+Get\+Bits(  )}} for working with bitfields.


\begin{DoxyParams}{Аргументы}
{\em puc\+Reg\+Buffer} & The buffer should be updated with the current coil values. The first discrete input starting at {\ttfamily us\+Address} must be stored at the LSB of the first byte in the buffer. If the requested number is not a multiple of eight the remaining bits should be set to zero. \\
\hline
{\em us\+Address} & The starting address of the first discrete input. \\
\hline
{\em us\+NDiscrete} & Number of discrete input values. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Возвращает}
The function must return one of the following error codes\+:
\begin{DoxyItemize}
\item e\+MBError\+Code\+::\+MB\+\_\+\+ENOERR If no error occurred. In this case a normal Modbus response is sent.
\item e\+MBError\+Code\+::\+MB\+\_\+\+ENOREG If no such discrete inputs exists. In this case a {\bfseries{ILLEGAL DATA ADDRESS}} exception frame is sent as a response.
\item e\+MBError\+Code\+::\+MB\+\_\+\+ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a {\bfseries{SLAVE DEVICE BUSY}} exception is sent as a response.
\item e\+MBError\+Code\+::\+MB\+\_\+\+EIO If an unrecoverable error occurred. In this case a {\bfseries{SLAVE DEVICE FAILURE}} exception is sent as a response. 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{group__modbus__registers_ga10d37e1d80224bf3b1eeb9e246d7582e}\label{group__modbus__registers_ga10d37e1d80224bf3b1eeb9e246d7582e}} 
\index{Modbus Registers@{Modbus Registers}!eMBRegHoldingCB@{eMBRegHoldingCB}}
\index{eMBRegHoldingCB@{eMBRegHoldingCB}!Modbus Registers@{Modbus Registers}}
\doxysubsubsection{\texorpdfstring{eMBRegHoldingCB()}{eMBRegHoldingCB()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__modbus_ga9e7fce8c431cb0e521c67f7f36dd823d}{e\+MBError\+Code}} e\+MBReg\+Holding\+CB (\begin{DoxyParamCaption}\item[{UCHAR $\ast$}]{puc\+Reg\+Buffer,  }\item[{USHORT}]{us\+Address,  }\item[{USHORT}]{us\+NRegs,  }\item[{\mbox{\hyperlink{group__modbus_gaf1398cbbeb317b1dbd0276b275f5b0f8}{e\+MBRegister\+Mode}}}]{e\+Mode }\end{DoxyParamCaption})}



Callback function used if a {\itshape Holding Register} value is read or written by the protocol stack. The starting register address is given by {\ttfamily us\+Address} and the last register is given by {\ttfamily us\+Address + us\+NRegs -\/ 1}. 


\begin{DoxyParams}{Аргументы}
{\em puc\+Reg\+Buffer} & If the application registers values should be updated the buffer points to the new registers values. If the protocol stack needs to now the current values the callback function should write them into this buffer. \\
\hline
{\em us\+Address} & The starting address of the register. \\
\hline
{\em us\+NRegs} & Number of registers to read or write. \\
\hline
{\em e\+Mode} & If e\+MBRegister\+Mode\+::\+MB\+\_\+\+REG\+\_\+\+WRITE the application register values should be updated from the values in the buffer. For example this would be the case when the Modbus master has issued an {\bfseries{WRITE SINGLE REGISTER}} command. If the value e\+MBRegister\+Mode\+::\+MB\+\_\+\+REG\+\_\+\+READ the application should copy the current values into the buffer {\ttfamily puc\+Reg\+Buffer}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Возвращает}
The function must return one of the following error codes\+:
\begin{DoxyItemize}
\item e\+MBError\+Code\+::\+MB\+\_\+\+ENOERR If no error occurred. In this case a normal Modbus response is sent.
\item e\+MBError\+Code\+::\+MB\+\_\+\+ENOREG If the application can not supply values for registers within this range. In this case a {\bfseries{ILLEGAL DATA ADDRESS}} exception frame is sent as a response.
\item e\+MBError\+Code\+::\+MB\+\_\+\+ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a {\bfseries{SLAVE DEVICE BUSY}} exception is sent as a response.
\item e\+MBError\+Code\+::\+MB\+\_\+\+EIO If an unrecoverable error occurred. In this case a {\bfseries{SLAVE DEVICE FAILURE}} exception is sent as a response. 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{group__modbus__registers_ga7816677520b1eb2ebecf15060a41bc81}\label{group__modbus__registers_ga7816677520b1eb2ebecf15060a41bc81}} 
\index{Modbus Registers@{Modbus Registers}!eMBRegInputCB@{eMBRegInputCB}}
\index{eMBRegInputCB@{eMBRegInputCB}!Modbus Registers@{Modbus Registers}}
\doxysubsubsection{\texorpdfstring{eMBRegInputCB()}{eMBRegInputCB()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__modbus_ga9e7fce8c431cb0e521c67f7f36dd823d}{e\+MBError\+Code}} e\+MBReg\+Input\+CB (\begin{DoxyParamCaption}\item[{UCHAR $\ast$}]{puc\+Reg\+Buffer,  }\item[{USHORT}]{us\+Address,  }\item[{USHORT}]{us\+NRegs }\end{DoxyParamCaption})}



Callback function used if the value of a {\itshape Input Register} is required by the protocol stack. The starting register address is given by {\ttfamily us\+Address} and the last register is given by {\ttfamily us\+Address + us\+NRegs -\/ 1}. 


\begin{DoxyParams}{Аргументы}
{\em puc\+Reg\+Buffer} & \mbox{\hyperlink{class_a}{A}} buffer where the callback function should write the current value of the modbus registers to. \\
\hline
{\em us\+Address} & The starting address of the register. Input registers are in the range 1 -\/ 65535. \\
\hline
{\em us\+NRegs} & Number of registers the callback function must supply.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Возвращает}
The function must return one of the following error codes\+:
\begin{DoxyItemize}
\item e\+MBError\+Code\+::\+MB\+\_\+\+ENOERR If no error occurred. In this case a normal Modbus response is sent.
\item e\+MBError\+Code\+::\+MB\+\_\+\+ENOREG If the application can not supply values for registers within this range. In this case a {\bfseries{ILLEGAL DATA ADDRESS}} exception frame is sent as a response.
\item e\+MBError\+Code\+::\+MB\+\_\+\+ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a {\bfseries{SLAVE DEVICE BUSY}} exception is sent as a response.
\item e\+MBError\+Code\+::\+MB\+\_\+\+EIO If an unrecoverable error occurred. In this case a {\bfseries{SLAVE DEVICE FAILURE}} exception is sent as a response. 
\end{DoxyItemize}
\end{DoxyReturn}
